package studio.kdb;

import studio.core.Credentials;
import studio.core.DefaultAuthenticationMechanism;
import studio.ui.ServerList;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.List;
import java.text.NumberFormat;
import java.text.DecimalFormat;
import java.awt.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Config {
    public static String imageBase = "/de/skelton/images/";
    public static String imageBase2 = "/de/skelton/utils/";

    private static final String PATH = System.getProperties().getProperty("user.home") + "/.studioforkdb/";
    private static final String FILENAME = PATH + "studio.properties";
    private static final String VERSION = "1.1";

    private final Properties p = new Properties();
    private final static Config instance = new Config();

    private Config() {
        init();
    }

    public Font getFont() {
        String name = p.getProperty("font.name", "Monospaced");
        int  size = Integer.parseInt(p.getProperty("font.size","14"));

        Font f = new Font(name, Font.PLAIN, size);
        setFont(f);

        return f;
    }

    public String getEncoding() {
        return p.getProperty("encoding", "UTF-8");
    }

    public void setFont(Font f) {
        p.setProperty("font.name", f.getFamily());
        p.setProperty("font.size", "" + f.getSize());
        save();
    }

    public Color getColorForToken(String tokenType, Color defaultColor) {
        String s = p.getProperty("token." + tokenType);
        if (s != null) {
            return new Color(Integer.parseInt(s, 16));
        }

        setColorForToken(tokenType, defaultColor);
        return defaultColor;
    }

    public void setColorForToken(String tokenType, Color c) {
        p.setProperty("token." + tokenType, Integer.toHexString(c.getRGB()).substring(2));
        save();
    }

    public Color getDefaultBackgroundColor() {
        return getColorForToken("BACKGROUND", Color.white);
    }

    public synchronized NumberFormat getNumberFormat() {
        String key = p.getProperty("DecimalFormat", "#.#######");

        return new DecimalFormat(key);
    }

    public static Config getInstance() {
        return instance;
    }

    private void init() {
        Path file = Paths.get(FILENAME);
        Path dir = file.getParent();
        if (Files.notExists(dir)) {
            try {
                Files.createDirectories(dir);
            } catch (IOException e) {
                System.err.println("Can't create configuration folder: " + PATH);
            }
            return;
        }

        try {
            InputStream in = Files.newInputStream(file);
            p.load(in);
            in.close();
        } catch (IOException e) {
            System.err.println("Cant't read configuration from file " + FILENAME);
            e.printStackTrace(System.err);
        }
    }


    public void save() {
        try {
            OutputStream out = new FileOutputStream(FILENAME);
            p.put("version", VERSION);
            p.store(out, "Auto-generated by Studio for kdb+");
            out.close();
        } catch (IOException e) {
            System.err.println("Can't save configuration to " + FILENAME);
            e.printStackTrace(System.err);  //To change body of catch statement use Options | File Templates.
        }
    }

    // "".split(",") return {""}; we need to get zero length array
    private String[] split(String str) {
        str = str.trim();
        if (str.length() == 0) return new String[0];
        return str.split(",");
    }

    public String[] getQKeywords() {
        String key = p.getProperty("qkeywords", "");
        return split(key);
    }

    public String getLRUServer() {
        return p.getProperty("lruServer", "");
    }

    public void setLRUServer(Server s) {
        if (s == null) return; // May be it should be an exception ?

        p.put("lruServer", s.getName());
        save();
    }


    public void saveQKeywords(String[] keywords) {
        p.put("qkeywords", String.join(",",keywords));
        save();
    }

    public void setAcceptedLicense(Date d) {
        p.put("licenseAccepted", d.toString());
        save();
    }

    public String[] getMRUFiles() {
        String mru = p.getProperty("mrufiles", "");
        return split(mru);
    }


    public void saveMRUFiles(String[] mruFiles) {
        String value = Stream.of(mruFiles).limit(9).collect(Collectors.joining(","));
        p.put("mrufiles", value);
        save();
    }

    public String getLookAndFeel() {
        return p.getProperty("lookandfeel");
    }

    public void setLookAndFeel(String lf) {
        p.put("lookandfeel", lf);
        save();
    }

    public List<String> getServerNames() {
        return Arrays.asList(split(p.getProperty("Servers", "")));
    }

    private void setServerNames(List<String> names) {
        p.setProperty("Servers", String.join(",",names));
        save();
    }

    public Server[] getServers() {
        return getServerNames().stream()
                .map(this::getServer)
                .toArray(Server[]::new);
    }


    // Resolve or create a new server by connection string.
    // Accept possible various connectionString such as:
    // `:host:port:user:password
    // host:port
    // If user and password are not found, defaults form default AuthenticationMechanism are used
    public Server getServerByConnectionString(String connectionString) {
        connectionString = connectionString.trim();
        if (connectionString.startsWith("`")) connectionString = connectionString.substring(1);
        if (connectionString.startsWith(":")) connectionString = connectionString.substring(1);

        String[] nodes = connectionString.split(":");
        if (nodes.length < 2) {
            throw new IllegalArgumentException("Wrong format of connection string");
        }

        String host = nodes[0];
        int port = Integer.parseInt(nodes[1]); // could throw NumberFormatException

        String auth = getDefaultAuthMechanism();
        String user, password;
        if (nodes.length == 2) {
            Credentials credentials = getDefaultCredentials(auth);
            user = credentials.getUsername();
            password = credentials.getPassword();
        } else {
            user = nodes[2];
            password = nodes.length > 3 ? Stream.of(nodes).skip(3).collect(Collectors.joining(":")) : "";
        }

        Color bgColor = Config.getInstance().getDefaultBackgroundColor();

        for (Server s: getServers()) {
            if (s.getHost().equals(host) && s.getPort() == port && s.getUsername().equals(user) && s.getPassword().equals(password)) {
                return s;
            }
        }

        return new Server("", host, port, user, password, bgColor, auth, false);
    }

    public Server getServer(String name) {
        String host = p.getProperty("server." + name + ".host", "");
        int port = Integer.parseInt(p.getProperty("server." + name + ".port", "-1"));
        String username = p.getProperty("server." + name + ".user", "");
        String password = p.getProperty("server." + name + ".password", "");
        String backgroundColor = p.getProperty("server." + name + ".backgroundColor", "FFFFFF");
        String authenticationMechanism = p.getProperty("server." + name + ".authenticationMechanism", DefaultAuthenticationMechanism.NAME);
        boolean useTLS = Boolean.parseBoolean(p.getProperty("server." + name + ".useTLS", "false"));
        Color c = new Color(Integer.parseInt(backgroundColor, 16));
        return new Server(name, host, port, username, password, c, authenticationMechanism, useTLS);

    }

    public void removeServer(Server server) {
        String name = server.getName();
        p.remove("server." + name + ".host");
        p.remove("server." + name + ".port");
        p.remove("server." + name + ".user");
        p.remove("server." + name + ".password");
        p.remove("server." + name + ".backgroundColor");
        p.remove("server." + name + ".authenticationMechanism");
        p.remove("server." + name + ".useTLS");

        List<String> list = new ArrayList<>(getServerNames());
        list.remove(name);
        setServerNames(list);
    }

    private void setServerDetails(Server server) {
        String name = server.getName();
        if (name.trim().length() == 0) {
            throw new IllegalArgumentException("Server name can't be empty");
        }
        if (name.contains(",")) {
            throw new IllegalArgumentException("Server name can't contains ,");
        }
        p.setProperty("server." + name + ".host", server.getHost());
        p.setProperty("server." + name + ".port", "" + server.getPort());
        p.setProperty("server." + name + ".user", "" + server.getUsername());
        p.setProperty("server." + name + ".password", "" + server.getPassword());
        p.setProperty("server." + name + ".backgroundColor", "" + Integer.toHexString(server.getBackgroundColor().getRGB()).substring(2));
        p.setProperty("server." + name + ".authenticationMechanism", server.getAuthenticationMechanism());
        p.setProperty("server." + name + ".useTLS", "" + server.getUseTLS());
    }

    public void addServer(Server server) {
        setServerDetails(server);

        String name = server.getName();
        List<String> list = Stream.of(getServers()).map(Server::getName).collect(Collectors.toList());
        if (! list.contains(name)) {
            list.add(name);
        }
        Collections.sort(list);
        p.setProperty("Servers",String.join(",", list));
        save();
    }

    public void setServers(Server[] servers) {
        Stream.of(servers).forEach(this::setServerDetails);
        setServerNames(Stream.of(servers).map(Server::getName).collect(Collectors.toList()));
    }

    public Credentials getDefaultCredentials(String authenticationMechanism) {
        String user = p.getProperty("auth." + authenticationMechanism + ".user", "");
        String password = p.getProperty("auth." + authenticationMechanism + ".password", "");
        return new Credentials(user, password);
    }

    public void setDefaultCredentials(String authenticationMechanism, Credentials credentials) {
        p.setProperty("auth." + authenticationMechanism + ".user", credentials.getUsername());
        p.setProperty("auth." + authenticationMechanism + ".password", credentials.getPassword());
        save();
    }

    public String getDefaultAuthMechanism() {
        return p.getProperty("auth", DefaultAuthenticationMechanism.NAME);
    }

    public void setDefaultAuthMechanism(String authMechanism) {
        p.setProperty("auth", authMechanism);
        save();
    }

    public void setServerListBounds(Rectangle rectangle) {
        p.setProperty("serverList.x", "" + (int)rectangle.getX());
        p.setProperty("serverList.y", "" + (int)rectangle.getY());
        p.setProperty("serverList.width", "" + (int)rectangle.getWidth());
        p.setProperty("serverList.height", "" + (int)rectangle.getHeight());
        save();
    }

    public Rectangle getServerListBounds() {
        String strX = p.getProperty("serverList.x");
        String strY = p.getProperty("serverList.y");
        String strWidth = p.getProperty("serverList.width");
        String strHeight = p.getProperty("serverList.height");

        if (strX != null && strY != null && strWidth != null && strHeight != null) {
            return new Rectangle(Integer.parseInt(strX), Integer.parseInt(strY),
                                Integer.parseInt(strWidth), Integer.parseInt(strHeight));
        }

        DisplayMode displayMode = GraphicsEnvironment.getLocalGraphicsEnvironment()
                                            .getDefaultScreenDevice().getDisplayMode();

        int width = displayMode.getWidth();
        int height = displayMode.getHeight();

        int w = Math.min(width / 2, ServerList.DEFAULT_WIDTH);
        int h = Math.min(height / 2, ServerList.DEFAULT_HEIGHT);
        int x = (width - w) / 2;
        int y = (height - h) / 2;
        return new Rectangle(x,y,w,h);
    }

}
